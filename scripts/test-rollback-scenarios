#!/usr/bin/env bash
set -euo pipefail

# Test rollback scenarios for deployment workflows
# This script simulates various failure conditions to test rollback mechanisms

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Source retry functionality
source "$SCRIPT_DIR/lib/retry.sh"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() {
    echo -e "${BLUE}[TEST]${NC} $*"
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*"
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $*"
}

error() {
    echo -e "${RED}[ERROR]${NC} $*"
}

usage() {
    cat << EOF
Usage: $0 [OPTION]

Test rollback scenarios for GitOps deployment workflows.

Options:
    --scenario <name>    Run specific test scenario
                        Available: terraform-failure, flux-failure, secrets-failure
    --dry-run           Show what would be tested without executing
    --cleanup           Clean up test artifacts and restore original state
    --help              Show this help message

Test Scenarios:
    terraform-failure   Simulate Terraform apply failure and test rollback
    flux-failure        Simulate Flux bootstrap failure and test cleanup
    secrets-failure     Simulate secrets generation failure and test recovery
    all                 Run all test scenarios (default)

Examples:
    $0 --scenario terraform-failure
    $0 --dry-run
    $0 --cleanup

EOF
}

check_prerequisites() {
    log "Checking prerequisites..."
    
    # Check if we're in a git repository
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        error "This script must be run from within a Git repository"
        exit 1
    fi
    
    # Check if required tools are available
    local required_tools=("gh" "terraform" "kubectl" "flux" "yq")
    for tool in "${required_tools[@]}"; do
        if ! command -v "$tool" > /dev/null 2>&1; then
            error "Required tool '$tool' is not installed or not in PATH"
            exit 1
        fi
    done
    
    # Check if config.yaml exists
    if [ ! -f "$PROJECT_ROOT/config.yaml" ]; then
        error "config.yaml not found. Please ensure the project is properly configured."
        exit 1
    fi
    
    success "Prerequisites check passed"
}

backup_current_state() {
    log "Creating backup of current state..."
    
    local backup_dir="$PROJECT_ROOT/.test-rollback-backup-$(date +%Y%m%d-%H%M%S)"
    mkdir -p "$backup_dir"
    
    # Backup workflows
    cp -r "$PROJECT_ROOT/.github/workflows" "$backup_dir/"
    
    # Backup any terraform state if it exists
    if [ -d "$PROJECT_ROOT/terraform/digitalocean" ]; then
        cp -r "$PROJECT_ROOT/terraform/digitalocean" "$backup_dir/"
    fi
    
    echo "$backup_dir" > "$PROJECT_ROOT/.test-rollback-backup-location"
    
    success "State backed up to: $backup_dir"
}

restore_original_state() {
    log "Restoring original state..."
    
    if [ -f "$PROJECT_ROOT/.test-rollback-backup-location" ]; then
        local backup_dir
        backup_dir=$(cat "$PROJECT_ROOT/.test-rollback-backup-location")
        
        if [ -d "$backup_dir" ]; then
            # Restore workflows
            cp -r "$backup_dir/workflows" "$PROJECT_ROOT/.github/"
            
            # Restore terraform directory if it was backed up
            if [ -d "$backup_dir/digitalocean" ]; then
                cp -r "$backup_dir/digitalocean" "$PROJECT_ROOT/terraform/"
            fi
            
            success "Original state restored"
            
            # Clean up backup
            rm -rf "$backup_dir"
            rm -f "$PROJECT_ROOT/.test-rollback-backup-location"
        else
            warning "Backup directory not found: $backup_dir"
        fi
    else
        warning "No backup location file found"
    fi
}

test_terraform_failure() {
    log "Testing Terraform failure rollback scenario..."
    
    # Create a temporary workflow that intentionally fails terraform apply
    local test_workflow="$PROJECT_ROOT/.github/workflows/test-terraform-failure.yml"
    
    cat > "$test_workflow" << 'EOF'
name: Test Terraform Failure Rollback

on:
  workflow_dispatch:

jobs:
  test-terraform-failure:
    name: Test Terraform Apply Failure
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: vars.IS_TEMPLATE != 'true'
    defaults:
      run:
        working-directory: terraform/digitalocean
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.12.1
      
      - name: Create Invalid Terraform Config
        run: |
          # Create an invalid configuration that will cause apply to fail
          cat > test-failure.tf << EOF
          resource "digitalocean_droplet" "invalid" {
            name   = "test-invalid-${random_id.test.hex}"
            size   = "invalid-size-that-does-not-exist"
            image  = "ubuntu-22-04-x64"
            region = "nyc1"
          }
          
          resource "random_id" "test" {
            byte_length = 4
          }
          EOF
      
      - name: Terraform Init
        run: terraform init
        env:
          TF_VAR_do_token: ${{ secrets.DIGITALOCEAN_TOKEN }}
      
      - name: Backup State (Should Work)
        run: |
          echo "Creating state backup..."
          if terraform state list > /dev/null 2>&1; then
            terraform state pull > backup.tfstate
            echo "State backed up successfully"
          else
            echo "No existing state to backup"
          fi
      
      - name: Terraform Apply (Should Fail)
        run: |
          echo "This should fail due to invalid droplet size..."
          terraform apply -auto-approve
        env:
          TF_VAR_do_token: ${{ secrets.DIGITALOCEAN_TOKEN }}
EOF
    
    log "Created test workflow: $test_workflow"
    
    if [ "$DRY_RUN" = "true" ]; then
        success "DRY RUN: Would trigger workflow and monitor for rollback behavior"
        return 0
    fi
    
    # Trigger the workflow
    log "Triggering test workflow..."
    if gh workflow run test-terraform-failure.yml; then
        success "Test workflow triggered successfully"
        
        # Monitor the workflow
        log "Monitoring workflow execution..."
        sleep 30 # Give it time to start
        
        # Check workflow status
        local run_id
        run_id=$(gh run list --workflow=test-terraform-failure.yml --limit=1 --json databaseId --jq '.[0].databaseId')
        
        if [ -n "$run_id" ]; then
            log "Monitoring run ID: $run_id"
            gh run watch "$run_id" || true # Don't fail if workflow fails (that's expected)
            
            # Check if rollback job ran
            local rollback_status
            rollback_status=$(gh run view "$run_id" --json jobs --jq '.jobs[] | select(.name | contains("Rollback")) | .conclusion')
            
            if [ "$rollback_status" = "success" ]; then
                success "Rollback mechanism worked correctly"
            elif [ "$rollback_status" = "failure" ]; then
                warning "Rollback job ran but failed"
            else
                warning "Rollback job did not run as expected"
            fi
        else
            error "Could not find workflow run ID"
        fi
    else
        error "Failed to trigger test workflow"
    fi
    
    # Clean up test workflow
    rm -f "$test_workflow"
}

test_flux_failure() {
    log "Testing Flux failure cleanup scenario..."
    
    if [ "$DRY_RUN" = "true" ]; then
        success "DRY RUN: Would simulate Flux bootstrap failure and test cleanup"
        return 0
    fi
    
    # This would require a more complex setup to properly test
    warning "Flux failure testing requires manual setup - simulating check..."
    
    # Simulate checking for cleanup logic
    if grep -q "cleanup-on-failure" "$PROJECT_ROOT/.github/workflows/cluster-deploy.yml"; then
        success "Flux cleanup job found in workflow"
    else
        error "Flux cleanup job not found in workflow"
    fi
}

test_secrets_failure() {
    log "Testing secrets generation failure scenario..."
    
    if [ "$DRY_RUN" = "true" ]; then
        success "DRY RUN: Would simulate secrets failure and test recovery"
        return 0
    fi
    
    # Check if secrets generation has proper error handling
    if [ -f "$PROJECT_ROOT/scripts/generate-secrets" ]; then
        log "Checking secrets generation script for error handling..."
        
        if grep -q "set -e" "$PROJECT_ROOT/scripts/generate-secrets"; then
            success "Secrets script has proper error handling (set -e)"
        else
            warning "Secrets script may not have proper error handling"
        fi
        
        if grep -q "trap" "$PROJECT_ROOT/scripts/generate-secrets"; then
            success "Secrets script has cleanup traps"
        else
            warning "Secrets script may not have cleanup mechanisms"
        fi
    else
        error "Secrets generation script not found"
    fi
}

cleanup_test_artifacts() {
    log "Cleaning up test artifacts..."
    
    # Remove any test workflows
    find "$PROJECT_ROOT/.github/workflows" -name "test-*.yml" -delete 2>/dev/null || true
    
    # Remove test terraform files
    find "$PROJECT_ROOT/terraform" -name "test-*.tf" -delete 2>/dev/null || true
    
    # Remove backup files
    find "$PROJECT_ROOT" -name "*.backup" -delete 2>/dev/null || true
    
    # Restore original state if backup exists
    restore_original_state
    
    success "Test artifacts cleaned up"
}

main() {
    local scenario="all"
    local cleanup_only=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --scenario)
                scenario="$2"
                shift 2
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --cleanup)
                cleanup_only=true
                shift
                ;;
            --help)
                usage
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done
    
    # Set default for DRY_RUN if not set
    DRY_RUN=${DRY_RUN:-false}
    
    if [ "$cleanup_only" = "true" ]; then
        cleanup_test_artifacts
        exit 0
    fi
    
    log "Starting rollback scenario tests..."
    log "Scenario: $scenario"
    log "Dry run: $DRY_RUN"
    
    check_prerequisites
    
    if [ "$DRY_RUN" = "false" ]; then
        backup_current_state
    fi
    
    case $scenario in
        terraform-failure)
            test_terraform_failure
            ;;
        flux-failure)
            test_flux_failure
            ;;
        secrets-failure)
            test_secrets_failure
            ;;
        all)
            test_terraform_failure
            test_flux_failure
            test_secrets_failure
            ;;
        *)
            error "Unknown scenario: $scenario"
            usage
            exit 1
            ;;
    esac
    
    if [ "$DRY_RUN" = "false" ]; then
        log "Test completed. Run with --cleanup to remove test artifacts."
    fi
    
    success "Rollback scenario testing completed"
}

# Handle script interruption
trap 'error "Script interrupted"; cleanup_test_artifacts; exit 1' INT TERM

main "$@"