#!/usr/bin/env bash
# Backup restoration test script
# Tests backup and restore functionality in a safe manner

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Import retry utility
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/lib/retry.sh"

# Configuration
TEST_NAMESPACE="backup-test"
CLEANUP_ON_SUCCESS=${CLEANUP_ON_SUCCESS:-true}

log() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

usage() {
    cat << EOF
Usage: $0 [OPTIONS] COMMAND

Test backup and restore functionality

Commands:
  postgres SERVICE    Test PostgreSQL backup/restore for specific service
  velero [BACKUP]     Test Velero backup/restore (optionally from specific backup)
  full               Test full disaster recovery scenario

Options:
  -h, --help         Show this help message
  -n, --namespace    Test namespace (default: backup-test)
  --no-cleanup       Don't cleanup test resources on success

Examples:
  $0 postgres keycloak
  $0 velero daily-application-backup-20240101-120000
  $0 full

EOF
}

# Cleanup function
cleanup() {
    if [[ "${CLEANUP_ON_SUCCESS}" == "true" ]]; then
        log "Cleaning up test resources..."
        kubectl delete namespace "${TEST_NAMESPACE}" --ignore-not-found=true
        success "Cleanup completed"
    else
        warning "Skipping cleanup (--no-cleanup specified)"
    fi
}

# Test PostgreSQL backup and restore
test_postgres_restore() {
    local service="$1"
    local namespace="${service}"
    local cluster_name="${service}-pg"
    
    log "Testing PostgreSQL backup/restore for ${service}..."
    
    # Check if source cluster exists
    if ! kubectl get cluster "${cluster_name}" -n "${namespace}" >/dev/null 2>&1; then
        error "Source cluster ${cluster_name} not found in namespace ${namespace}"
        return 1
    fi
    
    # Create test namespace
    kubectl create namespace "${TEST_NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -
    
    # Copy backup credentials to test namespace
    local backup_secret="${service}-postgres-backup-credentials"
    if kubectl get secret "${backup_secret}" -n "${namespace}" >/dev/null 2>&1; then
        kubectl get secret "${backup_secret}" -n "${namespace}" -o yaml | \
        sed "s/namespace: ${namespace}/namespace: ${TEST_NAMESPACE}/" | \
        kubectl apply -f -
        success "Copied backup credentials to test namespace"
    else
        error "Backup credentials secret ${backup_secret} not found"
        return 1
    fi
    
    # Create recovery cluster configuration
    local recovery_cluster_name="${service}-test-recovery"
    cat > "/tmp/${recovery_cluster_name}.yaml" << EOF
apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: ${recovery_cluster_name}
  namespace: ${TEST_NAMESPACE}
spec:
  instances: 1
  
  postgresql:
    parameters:
      max_connections: "100"
      shared_buffers: "64MB"
      
  bootstrap:
    recovery:
      source: ${cluster_name}
      
  storage:
    size: 5Gi
    storageClass: do-block-storage
    
  resources:
    requests:
      memory: "256Mi"
      cpu: "100m"
    limits:
      memory: "512Mi"
      cpu: "250m"
      
  backup:
    retentionPolicy: "7d"
    barmanObjectStore:
      destinationPath: "s3://{{ (datasource "config").cluster.name }}-backup/${service}-postgres"
      s3Credentials:
        accessKeyId:
          name: ${backup_secret}
          key: ACCESS_KEY_ID
        secretAccessKey:
          name: ${backup_secret}
          key: SECRET_ACCESS_KEY
      endpointURL: "https://{{ (datasource "config").cluster.region }}.digitaloceanspaces.com"
EOF
    
    # Apply recovery cluster
    log "Creating recovery cluster ${recovery_cluster_name}..."
    kubectl apply -f "/tmp/${recovery_cluster_name}.yaml"
    
    # Wait for cluster to be ready
    log "Waiting for recovery cluster to be ready..."
    if retry_with_backoff 30 5 kubectl wait --for=condition=Ready cluster "${recovery_cluster_name}" -n "${TEST_NAMESPACE}" --timeout=60s; then
        success "Recovery cluster is ready"
    else
        error "Recovery cluster failed to become ready"
        kubectl describe cluster "${recovery_cluster_name}" -n "${TEST_NAMESPACE}"
        return 1
    fi
    
    # Test database connectivity
    log "Testing database connectivity..."
    local pod_name
    pod_name=$(kubectl get pods -n "${TEST_NAMESPACE}" -l "postgresql=true,postgresql.cnpg.io/cluster=${recovery_cluster_name}" -o jsonpath='{.items[0].metadata.name}')
    
    if [[ -n "${pod_name}" ]]; then
        if kubectl exec "${pod_name}" -n "${TEST_NAMESPACE}" -- pg_isready -U postgres >/dev/null 2>&1; then
            success "Database connectivity verified"
        else
            error "Database connectivity test failed"
            return 1
        fi
    else
        error "No PostgreSQL pods found for recovery cluster"
        return 1
    fi
    
    # Test data verification (basic check)
    log "Performing basic data verification..."
    local db_name="${service}"
    if kubectl exec "${pod_name}" -n "${TEST_NAMESPACE}" -- psql -U "${service}" -d "${db_name}" -c "SELECT 1;" >/dev/null 2>&1; then
        success "Database ${db_name} is accessible"
    else
        warning "Database ${db_name} verification had issues (this may be expected for test restores)"
    fi
    
    success "PostgreSQL backup/restore test completed for ${service}"
    
    # Cleanup
    rm -f "/tmp/${recovery_cluster_name}.yaml"
}

# Test Velero backup and restore
test_velero_restore() {
    local backup_name="${1:-}"
    
    log "Testing Velero backup/restore..."
    
    # Check if Velero is available
    if ! command -v velero >/dev/null 2>&1; then
        error "Velero CLI not found. Please install velero CLI tool."
        return 1
    fi
    
    # List available backups if none specified
    if [[ -z "${backup_name}" ]]; then
        log "Available backups:"
        velero backup get --output table
        
        # Get most recent successful backup
        backup_name=$(velero backup get --output json | jq -r '.items[] | select(.status.phase == "Completed") | .metadata.name' | head -1)
        
        if [[ -z "${backup_name}" ]]; then
            error "No completed backups found"
            return 1
        fi
        
        log "Using most recent backup: ${backup_name}"
    fi
    
    # Create test namespace
    kubectl create namespace "${TEST_NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -
    
    # Create restore configuration
    local restore_name="test-restore-$(date +%Y%m%d-%H%M%S)"
    
    log "Creating restore ${restore_name} from backup ${backup_name}..."
    
    # Perform restore to test namespace
    velero restore create "${restore_name}" \
        --from-backup "${backup_name}" \
        --namespace-mappings "keycloak:${TEST_NAMESPACE}-keycloak,mattermost:${TEST_NAMESPACE}-mattermost,nextcloud:${TEST_NAMESPACE}-nextcloud,mailu:${TEST_NAMESPACE}-mailu" \
        --wait
    
    # Check restore status
    local restore_phase
    restore_phase=$(velero restore get "${restore_name}" --output json | jq -r '.status.phase')
    
    if [[ "${restore_phase}" == "Completed" ]]; then
        success "Velero restore completed successfully"
        
        # List restored resources
        log "Restored resources:"
        kubectl get all -n "${TEST_NAMESPACE}-keycloak" 2>/dev/null || true
        kubectl get all -n "${TEST_NAMESPACE}-mattermost" 2>/dev/null || true
        kubectl get all -n "${TEST_NAMESPACE}-nextcloud" 2>/dev/null || true
        kubectl get all -n "${TEST_NAMESPACE}-mailu" 2>/dev/null || true
        
    else
        error "Velero restore failed with phase: ${restore_phase}"
        velero restore describe "${restore_name}"
        return 1
    fi
    
    success "Velero backup/restore test completed"
}

# Test full disaster recovery
test_full_recovery() {
    log "Testing full disaster recovery scenario..."
    
    warning "This is a simulation - actual disaster recovery would involve infrastructure recreation"
    
    # Test PostgreSQL restores for all services
    local services=("keycloak" "mattermost" "nextcloud" "mailu")
    
    for service in "${services[@]}"; do
        log "Testing ${service} PostgreSQL recovery..."
        if test_postgres_restore "${service}"; then
            success "${service} PostgreSQL recovery test passed"
        else
            error "${service} PostgreSQL recovery test failed"
        fi
    done
    
    # Test Velero restore
    log "Testing Velero application recovery..."
    if test_velero_restore; then
        success "Velero application recovery test passed"
    else
        error "Velero application recovery test failed"
    fi
    
    success "Full disaster recovery test completed"
}

# Main function
main() {
    local command=""
    local service=""
    local backup_name=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                usage
                exit 0
                ;;
            -n|--namespace)
                TEST_NAMESPACE="$2"
                shift 2
                ;;
            --no-cleanup)
                CLEANUP_ON_SUCCESS=false
                shift
                ;;
            postgres)
                command="postgres"
                service="$2"
                shift 2
                ;;
            velero)
                command="velero"
                if [[ $# -gt 1 ]] && [[ "$2" != -* ]]; then
                    backup_name="$2"
                    shift 2
                else
                    shift
                fi
                ;;
            full)
                command="full"
                shift
                ;;
            *)
                error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done
    
    # Validate command
    if [[ -z "${command}" ]]; then
        error "No command specified"
        usage
        exit 1
    fi
    
    # Set trap for cleanup
    trap cleanup EXIT
    
    # Execute command
    case "${command}" in
        postgres)
            if [[ -z "${service}" ]]; then
                error "Service name required for postgres command"
                exit 1
            fi
            test_postgres_restore "${service}"
            ;;
        velero)
            test_velero_restore "${backup_name}"
            ;;
        full)
            test_full_recovery
            ;;
    esac
    
    success "All tests completed successfully"
}

# Run main function
main "$@"