#!/usr/bin/env bash
set -euo pipefail

# Script to pull secrets from GitHub repository secrets back to local .envrc.secrets
# Uses the gh CLI tool to retrieve secrets

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
    echo -e "${BLUE}ℹ️  $1${NC}"
}

print_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

print_error() {
    echo -e "${RED}❌ $1${NC}"
}

# Check if gh CLI is installed
if ! command -v gh &> /dev/null; then
    print_error "gh CLI is not installed. Please install it first:"
    echo "  https://cli.github.com/"
    exit 1
fi

# Check if authenticated with GitHub
if ! gh auth status &> /dev/null; then
    print_error "Not authenticated with GitHub. Please run 'gh auth login' first."
    exit 1
fi

# Find repository root
REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null || echo ".")
cd "$REPO_ROOT"

# Get repository name (owner/repo format)
REPO=$(gh repo view --json nameWithOwner -q .nameWithOwner)
if [ -z "$REPO" ]; then
    print_error "Could not determine repository. Make sure you're in a git repository."
    exit 1
fi

print_info "Pulling secrets from GitHub repository: $REPO"
echo

# Output file for pulled secrets
OUTPUT_FILE=".envrc.secrets.from-github"

# Create header for output file
cat > "$OUTPUT_FILE" << EOF
#!/usr/bin/env bash
# Secrets pulled from GitHub repository: $REPO
# Generated on: $(date)
# 
# Review and merge these with your .envrc.secrets file as needed
# Note: GitHub API doesn't allow retrieving actual secret values, only updating them
# This file contains the structure and placeholders

EOF

# Map of GitHub secret names to local env vars
declare -A secret_mapping
secret_mapping["GITHUB_TOKEN"]="GITHUB_TOKEN"
secret_mapping["SOPS_AGE_PRIVATE_KEY"]="SOPS_AGE_PRIVATE_KEY"
secret_mapping["DIGITALOCEAN_TOKEN"]="DIGITALOCEAN_TOKEN"
secret_mapping["SPACES_ACCESS_KEY_ID"]="SPACES_ACCESS_KEY_ID"
secret_mapping["SPACES_SECRET_ACCESS_KEY"]="SPACES_SECRET_ACCESS_KEY"
secret_mapping["KEYCLOAK_PROD_DB_PASSWORD"]="KEYCLOAK_DB_PASSWORD"
secret_mapping["KEYCLOAK_PROD_ADMIN_PASSWORD"]="KEYCLOAK_ADMIN_PASSWORD"
secret_mapping["MATTERMOST_PROD_DB_PASSWORD"]="MATTERMOST_DB_PASSWORD"
secret_mapping["MATTERMOST_PROD_OAUTH_CLIENT_ID"]="MATTERMOST_OAUTH_CLIENT_ID"
secret_mapping["MATTERMOST_PROD_OAUTH_CLIENT_SECRET"]="MATTERMOST_OAUTH_CLIENT_SECRET"
secret_mapping["NEXTCLOUD_PROD_DB_PASSWORD"]="NEXTCLOUD_DB_PASSWORD"
secret_mapping["NEXTCLOUD_PROD_OIDC_CLIENT_ID"]="NEXTCLOUD_OIDC_CLIENT_ID"
secret_mapping["NEXTCLOUD_PROD_OIDC_CLIENT_SECRET"]="NEXTCLOUD_OIDC_CLIENT_SECRET"
secret_mapping["NEXTCLOUD_PROD_SPACES_ACCESS_KEY"]="NEXTCLOUD_SPACES_ACCESS_KEY"
secret_mapping["NEXTCLOUD_PROD_SPACES_SECRET_KEY"]="NEXTCLOUD_SPACES_SECRET_KEY"
secret_mapping["MAILU_PROD_OAUTH2_CLIENT_ID"]="MAILU_OAUTH2_CLIENT_ID"
secret_mapping["MAILU_PROD_OAUTH2_CLIENT_SECRET"]="MAILU_OAUTH2_CLIENT_SECRET"
secret_mapping["MAILU_PROD_OAUTH2_COOKIE_SECRET"]="MAILU_OAUTH2_COOKIE_SECRET"
secret_mapping["HAPPYVERTICAL_AWS_ACCESS_KEY_ID"]="HAPPYVERTICAL_AWS_ACCESS_KEY_ID"
secret_mapping["HAPPYVERTICAL_AWS_SECRET_ACCESS_KEY"]="HAPPYVERTICAL_AWS_SECRET_ACCESS_KEY"

# Get list of repository secrets
print_info "Fetching list of repository secrets..."
SECRETS_JSON=$(gh api repos/$REPO/actions/secrets --jq '.secrets[].name' 2>/dev/null || echo "")

if [ -z "$SECRETS_JSON" ]; then
    print_error "Could not fetch repository secrets. Make sure you have admin access to the repository."
    exit 1
fi

# Count of found secrets
found_count=0

print_info "Found the following secrets in the repository:"
echo

# Process each secret mapping
for github_secret in "${!secret_mapping[@]}"; do
    local_var="${secret_mapping[$github_secret]}"
    
    # Check if this secret exists in the repository
    if echo "$SECRETS_JSON" | grep -q "^${github_secret}$"; then
        print_success "$github_secret → $local_var"
        echo "# export ${local_var}=\"<value stored in GitHub secret: $github_secret>\"" >> "$OUTPUT_FILE"
        found_count=$((found_count + 1))
    fi
done

echo >> "$OUTPUT_FILE"
echo "# Note: GitHub API doesn't allow retrieving actual secret values" >> "$OUTPUT_FILE"
echo "# You'll need to manually fill in the values or use the existing .envrc.secrets" >> "$OUTPUT_FILE"

echo
print_info "Summary:"
echo "  Found $found_count secrets in the GitHub repository"
echo

print_warning "Important: GitHub's API doesn't allow retrieving the actual values of secrets"
print_warning "for security reasons. The secrets exist in the repository but cannot be downloaded."
echo
print_info "Options to recover your secret values:"
echo "  1. If you have an existing .envrc.secrets file with the values, use that"
echo "  2. If you have access to the running cluster, extract from encrypted SOPS files:"
echo "     ./scripts/secrets-extract-from-repo"
echo "  3. If you have the values stored elsewhere (password manager, etc), use those"
echo "  4. As a last resort, generate new secrets (but this will require updating all services)"
echo

# Create a more useful script that checks which secrets are missing locally
cat > "check-missing-secrets.sh" << 'EOF'
#!/usr/bin/env bash
# Check which secrets are defined in GitHub but missing in .envrc.secrets

source .envrc.secrets 2>/dev/null || true

echo "Checking which secrets need values..."
echo

missing=0
EOF

for github_secret in "${!secret_mapping[@]}"; do
    local_var="${secret_mapping[$github_secret]}"
    cat >> "check-missing-secrets.sh" << EOF
if [ -z "\${${local_var}:-}" ] || [[ "\${${local_var}}" == "your_"* ]]; then
    echo "  ❌ ${local_var} is missing or has placeholder value"
    missing=\$((missing + 1))
else
    echo "  ✅ ${local_var} is set"
fi
EOF
done

cat >> "check-missing-secrets.sh" << 'EOF'

echo
echo "Missing secrets: $missing"
EOF

chmod +x check-missing-secrets.sh

print_success "Created check-missing-secrets.sh to help identify which secrets need values"
print_info "Run ./check-missing-secrets.sh to see which secrets are missing in your .envrc.secrets"