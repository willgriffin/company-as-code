#!/usr/bin/env bash
set -euo pipefail

# Script to validate AWS credentials and Route53 access for external-dns
# Takes a domain as an argument and checks/creates appropriate permissions

usage() {
    echo "Usage: $0 <domain> [--create-credentials] [--json]"
    echo ""
    echo "Validates and optionally creates AWS credentials for external-dns integration."
    echo ""
    echo "Options:"
    echo "  --create-credentials    Create IAM user and access keys for external-dns"
    echo "  --json                  Output results as JSON for scripting"
    echo ""
    echo "Examples:"
    echo "  $0 example.com"
    echo "  $0 happyvertical.com --create-credentials"
    echo "  $0 happyvertical.com --create-credentials --json"
    echo ""
    echo "This script:"
    echo "  - Validates AWS CLI is configured and authenticated"
    echo "  - Checks if Route53 hosted zone exists for the domain"
    echo "  - Tests current credentials have required permissions"
    echo "  - Optionally creates dedicated IAM user with minimal permissions"
    echo ""
    exit 1
}

# Parse arguments
CREATE_CREDENTIALS=false
JSON_OUTPUT=false
DOMAIN=""

while [[ $# -gt 0 ]]; do
    case $1 in
        --create-credentials)
            CREATE_CREDENTIALS=true
            shift
            ;;
        --json)
            JSON_OUTPUT=true
            shift
            ;;
        -h|--help)
            usage
            ;;
        *)
            if [ -z "$DOMAIN" ]; then
                DOMAIN="$1"
            else
                echo "Error: Unknown argument: $1" >&2
                usage
            fi
            shift
            ;;
    esac
done

if [ -z "$DOMAIN" ]; then
    echo "Error: Domain argument is required" >&2
    echo ""
    usage
fi

# JSON output helpers
JSON_RESULT='{}'

add_to_json() {
    local key="$1"
    local value="$2"
    local is_string="${3:-true}"
    
    if [ "$is_string" = "true" ]; then
        JSON_RESULT=$(echo "$JSON_RESULT" | npx node-jq --arg k "$key" --arg v "$value" '. + {($k): $v}')
    else
        JSON_RESULT=$(echo "$JSON_RESULT" | npx node-jq --arg k "$key" --argjson v "$value" '. + {($k): $v}')
    fi
}

log() {
    if [ "$JSON_OUTPUT" = "false" ]; then
        echo "$@"
    fi
}

log_error() {
    if [ "$JSON_OUTPUT" = "false" ]; then
        echo "$@" >&2
    else
        # In JSON mode, capture errors for later output
        ERROR_MESSAGE="$*"
    fi
}

output_result() {
    if [ "$JSON_OUTPUT" = "true" ]; then
        echo "$JSON_RESULT" | npx node-jq '.'
    fi
}

# Initialize JSON result
add_to_json "domain" "$DOMAIN"
add_to_json "create_credentials" "$CREATE_CREDENTIALS" false
add_to_json "success" "false" false

# Check if AWS CLI is installed
if ! command -v aws &> /dev/null; then
    log_error "‚ùå Error: AWS CLI is not installed"
    add_to_json "error" "AWS CLI is not installed"
    add_to_json "aws_cli_installed" "false" false
    log_error ""
    log_error "Please install the AWS CLI:"
    log_error "  https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html"
    log_error ""
    log_error "Or using package managers:"
    log_error "  # macOS"
    log_error "  brew install awscli"
    log_error ""
    log_error "  # Ubuntu/Debian"
    log_error "  sudo apt-get install awscli"
    log_error ""
    output_result
    exit 1
fi

add_to_json "aws_cli_installed" "true" false

log "üîç Validating AWS Route53 access for domain: $DOMAIN"
log ""

# Check AWS CLI configuration
log "1. Checking AWS CLI configuration..."
if ! aws sts get-caller-identity &> /dev/null; then
    log_error "‚ùå AWS CLI is not configured or credentials are invalid"
    add_to_json "error" "AWS CLI not configured or credentials invalid"
    add_to_json "aws_configured" "false" false
    log_error ""
    log_error "Please configure AWS CLI with one of:"
    log_error "  1. aws configure (interactive setup)"
    log_error "  2. Export environment variables:"
    log_error "     export AWS_ACCESS_KEY_ID=your_access_key"
    log_error "     export AWS_SECRET_ACCESS_KEY=your_secret_key"
    log_error "     export AWS_DEFAULT_REGION=us-east-1"
    log_error "  3. Use AWS profiles: aws configure --profile myprofile"
    log_error ""
    log_error "üí° Hint: You may need to switch AWS accounts or add credentials to your environment"
    output_result
    exit 1
fi

add_to_json "aws_configured" "true" false

# Get current identity
IDENTITY=$(aws sts get-caller-identity --output json)
if command -v jq &> /dev/null || command -v npx &> /dev/null; then
    ACCOUNT_ID=$(echo "$IDENTITY" | npx node-jq -r '.Account')
    USER_ARN=$(echo "$IDENTITY" | npx node-jq -r '.Arn')
else
    log "‚ö†Ô∏è  Warning: jq is not installed. Using basic parsing..." >&2
    # Fallback parsing without jq
    ACCOUNT_ID=$(aws sts get-caller-identity --query 'Account' --output text)
    USER_ARN=$(aws sts get-caller-identity --query 'Arn' --output text)
fi

add_to_json "aws_account_id" "$ACCOUNT_ID"
add_to_json "aws_user_arn" "$USER_ARN"

log "   ‚úì AWS CLI configured"
log "   Account: $ACCOUNT_ID"
log "   Identity: $USER_ARN"
log ""

# Find hosted zone for the domain
log "2. Looking for Route53 hosted zone..."
HOSTED_ZONES=$(aws route53 list-hosted-zones --output json 2>/dev/null || echo '{"HostedZones":[]}')

if command -v jq &> /dev/null || command -v npx &> /dev/null; then
    ZONE_ID=$(echo "$HOSTED_ZONES" | npx node-jq -r --arg domain "$DOMAIN." '.HostedZones[] | select(.Name == $domain) | .Id' | head -1)
    ZONE_NAME=$(echo "$HOSTED_ZONES" | npx node-jq -r --arg domain "$DOMAIN." '.HostedZones[] | select(.Name == $domain) | .Name' | head -1)
else
    # Fallback without jq - basic grep approach
    ZONE_INFO=$(echo "$HOSTED_ZONES" | grep -A 10 -B 2 "\"$DOMAIN.\"" | head -20 || echo "")
    ZONE_ID=$(echo "$ZONE_INFO" | grep '"Id"' | cut -d'"' -f4 | head -1 || echo "")
    ZONE_NAME="$DOMAIN."
fi

if [ -z "$ZONE_ID" ] || [ "$ZONE_ID" = "null" ]; then
    log_error "‚ùå No hosted zone found for domain: $DOMAIN"
    add_to_json "error" "No hosted zone found for domain"
    add_to_json "hosted_zone_found" "false" false
    log_error ""
    log_error "Possible solutions:"
    log_error "  1. Create a hosted zone for $DOMAIN in Route53:"
    log_error "     aws route53 create-hosted-zone --name $DOMAIN --caller-reference \$(date +%s)"
    log_error ""
    log_error "  2. Check if you're using the correct AWS account"
    log_error "     - The domain might be in a different AWS account"
    log_error "     - Try: aws configure list-profiles"
    log_error "     - Switch profiles: export AWS_PROFILE=your-profile"
    log_error ""
    log_error "  3. Verify domain spelling and ensure it ends with a dot in Route53"
    log_error ""
    log_error "üí° Hint: You may need to switch AWS accounts or verify domain ownership"
    output_result
    exit 1
fi

# Clean up zone ID (remove /hostedzone/ prefix if present)
ZONE_ID=$(echo "$ZONE_ID" | sed 's|/hostedzone/||')

add_to_json "hosted_zone_found" "true" false
add_to_json "hosted_zone_id" "$ZONE_ID"
add_to_json "hosted_zone_name" "$ZONE_NAME"

log "   ‚úì Found hosted zone: $ZONE_NAME"
log "   Zone ID: $ZONE_ID"
log ""

# Test Route53 permissions
log "3. Testing Route53 permissions..."

# Test ListHostedZones permission (already tested above)
add_to_json "permissions_list_hosted_zones" "true" false
log "   ‚úì route53:ListHostedZones - OK"

# Test ChangeResourceRecordSets permission
log "   Testing route53:ChangeResourceRecordSets..."
TEST_RECORD="_external-dns-test.$DOMAIN"
CHANGE_BATCH=$(cat <<EOF
{
    "Changes": [{
        "Action": "UPSERT",
        "ResourceRecordSet": {
            "Name": "$TEST_RECORD",
            "Type": "TXT",
            "TTL": 60,
            "ResourceRecords": [{"Value": "\"external-dns-test-$(date +%s)\""}]
        }
    }]
}
EOF
)

if aws route53 change-resource-record-sets --hosted-zone-id "$ZONE_ID" --change-batch "$CHANGE_BATCH" &> /dev/null; then
    add_to_json "permissions_change_resource_record_sets" "true" false
    log "   ‚úì route53:ChangeResourceRecordSets - OK"
    
    # Clean up test record
    DELETE_BATCH=$(echo "$CHANGE_BATCH" | sed 's/"UPSERT"/"DELETE"/')
    aws route53 change-resource-record-sets --hosted-zone-id "$ZONE_ID" --change-batch "$DELETE_BATCH" &> /dev/null || true
else
    add_to_json "permissions_change_resource_record_sets" "false" false
    add_to_json "error" "Missing route53:ChangeResourceRecordSets permission"
    log_error "   ‚ùå route53:ChangeResourceRecordSets - FAILED"
    log_error ""
    log_error "The current AWS credentials don't have permission to modify DNS records."
    log_error ""
    log_error "Required IAM permissions for external-dns:"
    log_error "{"
    log_error "  \"Version\": \"2012-10-17\","
    log_error "  \"Statement\": ["
    log_error "    {"
    log_error "      \"Effect\": \"Allow\","
    log_error "      \"Action\": ["
    log_error "        \"route53:ChangeResourceRecordSets\""
    log_error "      ],"
    log_error "      \"Resource\": \"arn:aws:route53:::hostedzone/$ZONE_ID\""
    log_error "    },"
    log_error "    {"
    log_error "      \"Effect\": \"Allow\","
    log_error "      \"Action\": ["
    log_error "        \"route53:ListHostedZones\","
    log_error "        \"route53:ListResourceRecordSets\""
    log_error "      ],"
    log_error "      \"Resource\": \"*\""
    log_error "    }"
    log_error "  ]"
    log_error "}"
    log_error ""
    log_error "üí° Hint: You may need to:"
    log_error "  1. Switch to an AWS account with Route53 access"
    log_error "  2. Request additional IAM permissions"
    log_error "  3. Use different AWS credentials with Route53 access"
    output_result
    exit 1
fi

# Test ListResourceRecordSets permission
log "   Testing route53:ListResourceRecordSets..."
if aws route53 list-resource-record-sets --hosted-zone-id "$ZONE_ID" --max-items 1 &> /dev/null; then
    add_to_json "permissions_list_resource_record_sets" "true" false
    log "   ‚úì route53:ListResourceRecordSets - OK"
else
    add_to_json "permissions_list_resource_record_sets" "false" false
    log "   ‚ö†Ô∏è  route53:ListResourceRecordSets - Limited (may work but not optimal)"
fi

log ""
log "‚úÖ All Route53 permissions validated successfully!"

# Create dedicated credentials if requested
if [ "$CREATE_CREDENTIALS" = true ]; then
    log ""
    log "4. Creating dedicated IAM user for external-dns..."
    
    USER_NAME="external-dns-$(echo "$DOMAIN" | sed 's/\./-/g')"
    POLICY_NAME="ExternalDNS-$(echo "$DOMAIN" | sed 's/\./-/g')-Policy"
    
    # Check if user already exists
    if aws iam get-user --user-name "$USER_NAME" &> /dev/null; then
        log "   ‚ÑπÔ∏è  IAM user '$USER_NAME' already exists"
        
        # Check if user has access keys
        EXISTING_KEYS=$(aws iam list-access-keys --user-name "$USER_NAME" --output json)
        if command -v jq &> /dev/null || command -v npx &> /dev/null; then
            KEY_COUNT=$(echo "$EXISTING_KEYS" | npx node-jq '.AccessKeyMetadata | length')
        else
            KEY_COUNT=$(echo "$EXISTING_KEYS" | grep -c '"AccessKeyId"' || echo "0")
        fi
        
        if [ "$KEY_COUNT" -gt 0 ]; then
            echo "   ‚ö†Ô∏è  User already has $KEY_COUNT access key(s). Skipping key creation."
            echo "   üí° To create new keys, first delete existing ones:"
            echo "      aws iam list-access-keys --user-name $USER_NAME"
            echo "      aws iam delete-access-key --user-name $USER_NAME --access-key-id <KEY_ID>"
        else
            echo "   Creating new access key for existing user..."
            NEW_CREDENTIALS=$(aws iam create-access-key --user-name "$USER_NAME" --output json)
            if command -v jq &> /dev/null || command -v npx &> /dev/null; then
                NEW_ACCESS_KEY=$(echo "$NEW_CREDENTIALS" | npx node-jq -r '.AccessKey.AccessKeyId')
                NEW_SECRET_KEY=$(echo "$NEW_CREDENTIALS" | npx node-jq -r '.AccessKey.SecretAccessKey')
            else
                NEW_ACCESS_KEY=$(echo "$NEW_CREDENTIALS" | grep '"AccessKeyId"' | cut -d'"' -f4)
                NEW_SECRET_KEY=$(echo "$NEW_CREDENTIALS" | grep '"SecretAccessKey"' | cut -d'"' -f4)
            fi
            
            echo "   ‚úì Created new access key: $NEW_ACCESS_KEY"
            
            # Display credentials securely
            echo ""
            echo "üîë New AWS Credentials Created:"
            echo "   AWS_ACCESS_KEY_ID: $NEW_ACCESS_KEY"
            echo "   AWS_SECRET_ACCESS_KEY: $NEW_SECRET_KEY"
            echo ""
            echo "‚ö†Ô∏è  IMPORTANT: Store these credentials securely! They will not be shown again."
        fi
    else
        echo "   Creating IAM user: $USER_NAME"
        
        # Create IAM policy
        POLICY_DOC=$(cat <<EOF
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": [
                "route53:ChangeResourceRecordSets"
            ],
            "Resource": "arn:aws:route53:::hostedzone/$ZONE_ID"
        },
        {
            "Effect": "Allow",
            "Action": [
                "route53:ListHostedZones",
                "route53:ListResourceRecordSets"
            ],
            "Resource": "*"
        }
    ]
}
EOF
)
        
        # Create or update the policy
        if aws iam get-policy --policy-arn "arn:aws:iam::$ACCOUNT_ID:policy/$POLICY_NAME" &> /dev/null; then
            echo "   ‚ÑπÔ∏è  Policy '$POLICY_NAME' already exists, updating..."
            POLICY_VERSION=$(aws iam create-policy-version \
                --policy-arn "arn:aws:iam::$ACCOUNT_ID:policy/$POLICY_NAME" \
                --policy-document "$POLICY_DOC" \
                --set-as-default \
                --output json)
        else
            echo "   Creating IAM policy: $POLICY_NAME"
            aws iam create-policy \
                --policy-name "$POLICY_NAME" \
                --policy-document "$POLICY_DOC" \
                --description "Policy for external-dns to manage $DOMAIN DNS records" \
                > /dev/null
        fi
        
        # Create IAM user
        aws iam create-user \
            --user-name "$USER_NAME" \
            --tags "Key=Purpose,Value=external-dns" "Key=Domain,Value=$DOMAIN" \
            > /dev/null
        
        echo "   ‚úì Created IAM user: $USER_NAME"
        
        # Attach policy to user
        aws iam attach-user-policy \
            --user-name "$USER_NAME" \
            --policy-arn "arn:aws:iam::$ACCOUNT_ID:policy/$POLICY_NAME"
        
        echo "   ‚úì Attached policy to user"
        
        # Create access key
        echo "   Creating access key..."
        NEW_CREDENTIALS=$(aws iam create-access-key --user-name "$USER_NAME" --output json)
        
        if command -v jq &> /dev/null || command -v npx &> /dev/null; then
            NEW_ACCESS_KEY=$(echo "$NEW_CREDENTIALS" | npx node-jq -r '.AccessKey.AccessKeyId')
            NEW_SECRET_KEY=$(echo "$NEW_CREDENTIALS" | npx node-jq -r '.AccessKey.SecretAccessKey')
        else
            NEW_ACCESS_KEY=$(echo "$NEW_CREDENTIALS" | grep '"AccessKeyId"' | cut -d'"' -f4)
            NEW_SECRET_KEY=$(echo "$NEW_CREDENTIALS" | grep '"SecretAccessKey"' | cut -d'"' -f4)
        fi
        
        echo "   ‚úì Created access key: $NEW_ACCESS_KEY"
        
        # Display credentials securely
        echo ""
        echo "üîë New AWS Credentials Created:"
        echo "   User: $USER_NAME"
        echo "   Policy: $POLICY_NAME"
        echo "   AWS_ACCESS_KEY_ID: $NEW_ACCESS_KEY"
        echo "   AWS_SECRET_ACCESS_KEY: $NEW_SECRET_KEY"
        echo ""
        echo "‚ö†Ô∏è  IMPORTANT: Store these credentials securely! They will not be shown again."
        
        # Test the new credentials
        echo ""
        echo "5. Testing new credentials..."
        export AWS_ACCESS_KEY_ID="$NEW_ACCESS_KEY"
        export AWS_SECRET_ACCESS_KEY="$NEW_SECRET_KEY"
        
        if aws route53 list-hosted-zones --output table &> /dev/null; then
            echo "   ‚úì New credentials work correctly"
        else
            echo "   ‚ö†Ô∏è  New credentials may need a moment to propagate"
        fi
    fi
fi

# Mark as successful
add_to_json "success" "true" false

# Add credential information if created
if [ "$CREATE_CREDENTIALS" = true ] && [ -n "${NEW_ACCESS_KEY:-}" ]; then
    add_to_json "created_user" "$USER_NAME"
    add_to_json "created_access_key" "$NEW_ACCESS_KEY"
    add_to_json "created_secret_key" "$NEW_SECRET_KEY"
    add_to_json "created_policy" "$POLICY_NAME"
fi

log ""
log "Summary:"
log "  Domain: $DOMAIN"
log "  Hosted Zone ID: $ZONE_ID"
log "  AWS Account: $ACCOUNT_ID"
log "  Identity: $USER_ARN"

if [ "$CREATE_CREDENTIALS" = true ] && [ -n "${NEW_ACCESS_KEY:-}" ]; then
    log "  New User: $USER_NAME"
    log "  New Access Key: $NEW_ACCESS_KEY"
fi

log ""
log "üéâ Your AWS credentials are properly configured for external-dns!"
log ""
log "Next steps:"
log "  1. Set these credentials in your .envrc.secrets:"
if [ "$CREATE_CREDENTIALS" = true ] && [ -n "${NEW_ACCESS_KEY:-}" ]; then
    log "     export HAPPYVERTICAL_AWS_ACCESS_KEY_ID=\"$NEW_ACCESS_KEY\""
    log "     export HAPPYVERTICAL_AWS_SECRET_ACCESS_KEY=\"$NEW_SECRET_KEY\""
else
    log "     export HAPPYVERTICAL_AWS_ACCESS_KEY_ID=\"\$AWS_ACCESS_KEY_ID\""
    log "     export HAPPYVERTICAL_AWS_SECRET_ACCESS_KEY=\"\$AWS_SECRET_ACCESS_KEY\""
fi
log ""
log "  2. Run the secrets sync script:"
log "     ./scripts/secrets-sync-to-github"
log ""
log "  3. Generate encrypted secrets:"
log "     ./scripts/generate-encrypted-secrets"
log ""
log "  4. Deploy external-dns to your cluster"

# Output final JSON result
output_result